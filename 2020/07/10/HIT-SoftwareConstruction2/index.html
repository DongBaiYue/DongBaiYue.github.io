<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dongbaiyue.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前言本篇内容主要是总结一下CMU 17-214课程: Principles of Software Construction的课程PPT，以免遗忘。 状态：未完成。。">
<meta property="og:type" content="article">
<meta property="og:title" content="HIT-软件构造(二)">
<meta property="og:url" content="https://dongbaiyue.github.io/2020/07/10/HIT-SoftwareConstruction2/index.html">
<meta property="og:site_name" content="东百月的博客">
<meta property="og:description" content="前言本篇内容主要是总结一下CMU 17-214课程: Principles of Software Construction的课程PPT，以免遗忘。 状态：未完成。。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dongbaiyue.github.io/images/HIT-%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E4%BA%8C/%E6%8D%95%E8%8E%B7.JPG">
<meta property="og:image" content="https://dongbaiyue.github.io/images/HIT-%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E4%BA%8C/image-20200419220237703.png">
<meta property="og:image" content="https://dongbaiyue.github.io/images/HIT-%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E4%BA%8C/image-20200419223244912.png">
<meta property="og:image" content="https://dongbaiyue.github.io/images/HIT-%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E4%BA%8C/image-20200419231604316.png">
<meta property="og:image" content="https://dongbaiyue.github.io/images/HIT-%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E4%BA%8C/image-20200419231754350.png">
<meta property="og:image" content="https://dongbaiyue.github.io/images/HIT-SoftwareConstruction2/image-20200504202045054.png">
<meta property="article:published_time" content="2020-07-10T13:31:42.000Z">
<meta property="article:modified_time" content="2020-07-10T13:37:09.498Z">
<meta property="article:author" content="1180300308-刘义">
<meta property="article:tag" content="HIT">
<meta property="article:tag" content="课程学习">
<meta property="article:tag" content="软件构造">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dongbaiyue.github.io/images/HIT-%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E4%BA%8C/%E6%8D%95%E8%8E%B7.JPG">

<link rel="canonical" href="https://dongbaiyue.github.io/2020/07/10/HIT-SoftwareConstruction2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>HIT-软件构造(二) | 东百月的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="东百月的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">东百月的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">物质上的匮乏和精神上的无聊是人生的两大痛苦。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongbaiyue.github.io/2020/07/10/HIT-SoftwareConstruction2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="1180300308-刘义">
      <meta itemprop="description" content="这里是东百月的园地">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="东百月的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          HIT-软件构造(二)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-10 21:31:42 / 修改时间：21:37:09" itemprop="dateCreated datePublished" datetime="2020-07-10T21:31:42+08:00">2020-07-10</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/07/10/HIT-SoftwareConstruction2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/07/10/HIT-SoftwareConstruction2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇内容主要是总结一下<a href="https://www.cs.cmu.edu/~charlie/courses/17-214/2019-fall" target="_blank" rel="noopener">CMU 17-214课程: Principles of Software Construction</a>的课程PPT，以免遗忘。</p>
<p>状态：未完成。。</p>
<a id="more"></a>
<h3 id="Introduction-to-Java"><a href="#Introduction-to-Java" class="headerlink" title="Introduction to Java"></a>Introduction to Java</h3><p><strong>Hello World</strong></p>
<p>the “simplest” Java Program</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>class HelloWorld</code>：类名为HelloWorld的类，Java中任何程序必须使用一个类。</li>
<li><code>public</code>：指定谁能够访问这个方法。</li>
<li><code>static</code>：指定方法是属于类（被所有类实例共享）还是属于类实例（每个类实例都有不同的）。</li>
<li><code>void</code>：返回类型。</li>
<li><code>String[] args</code>：main方法必须声明命令行参数，即使main方法并没有使用它们。</li>
<li><code>System.out.println(&quot;Hello World!&quot;)</code>：使用核心库的System类打印”Hello World”到标准输出，进而显示在控制台上。</li>
</ul>
<p>可以看出，相对于其他程序语言（如c），Java的HelloWorld程序冗长一些，但这也有很多好处：</p>
<ul>
<li>适当的冗长能够减少错误、提高可读性。</li>
<li>现代IDE可以简化冗长，如一些IDE可以用<code>psvm</code>代替<code>public static void main</code>（反正eclipse不行，在eclipse中可以使用<code>main</code>然后”Alt+/“，”Alt+/“是提示快捷键）。</li>
<li>Java可能不是编写HelloWorld程序最好的语言，但是对于大规模程序而言Java是一种很好的语言。</li>
</ul>
<p><strong>Java类型系统(type system)</strong></p>
<ul>
<li>原始类型</li>
</ul>
<p><img src="/images/HIT-软件构造二/捕获.JPG" alt="原始路径"></p>
<p>廉价的、存储在桟上、只在运行时存在、值即身份。</p>
<ul>
<li>对象引用类型</li>
</ul>
<p><img src="/images/HIT-软件构造二/image-20200419220237703.png" alt="对象引用类型"></p>
<p>昂贵的、存储在堆上、需要垃圾收集、身份与值无关。</p>
<p>对象：域和行为的组合。行为，也称方法，方法是面向对象编程中对函数的叫法。</p>
<p>类：类定义了对象的类型和实现。不严格地说，一个类的方法就是它的应用程序接口(API)，定义了用户怎样与类的实例进行交互。</p>
<p>继承：子类继承父类，子类会继承父类可见的域和方法，并且可以重写父类的方法。</p>
<p>接口：定义一个类型，但没有实现。一个接口可以被多个扩展，一个类也可以实现多个接口。</p>
<p>注释(annotation)：如<code>@Override</code>、<code>@Deprecated</code>、<code>@SuppressWarnings</code>，仅是为了增强可读性，没有任何函数功能上的作用。</p>
<p>原始类型与包装类型</p>
<p><img src="/images/HIT-软件构造二/image-20200419223244912.png" alt="原始类型与包装类型"></p>
<ul>
<li>包装类型提供了对原始类型的包装，以便在需要对象类型时使用。<ul>
<li>典型的例子是集合，如<code>HashSet&lt;Integer&gt;</code>。</li>
</ul>
</li>
<li>包装类型默认初始化为<code>null</code>。</li>
<li>在两者都可以时，更倾向于使用原始类型。</li>
</ul>
<p>变量使用的基本原则：</p>
<ul>
<li>最小化局部变量的作用域，在变量使用时才声明它。</li>
<li>声明变量时进行初始化。</li>
<li>变量名使用常见的单词。</li>
</ul>
<p><strong>简易I/O</strong></p>
<p>输出：</p>
<ul>
<li><code>System.out.print</code>：非格式化的</li>
<li><code>System.out.printf</code>：格式化的，需要指明以什么格式输出</li>
</ul>
<p>输入</p>
<ul>
<li>命令行参数输入，如<code>java HelloWorld parameter</code></li>
<li>Scanner input，如</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">while</span>(in.hasNext())&#123; <span class="comment">// 以空格作为分割，判断是否到输入末尾</span></span><br><span class="line">    System.out.print(in.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>集合(Collection)</strong></p>
<p>collection是对象，它表示了一组对象，即collection是表示一组对象的对象。</p>
<p>Java中collection的类和接口是分离的，接口有：</p>
<p><img src="/images/HIT-软件构造二/image-20200419231604316.png" alt="类接口"></p>
<p>每一个接口都有不止一种实现，比如</p>
<p><img src="/images/HIT-软件构造二/image-20200419231754350.png" alt="Set实现"></p>
<p>数组与集合：</p>
<ul>
<li>数组不是集合。</li>
<li><p>数组与集合不要混合使用</p>
<ul>
<li>如果你尝试混合使用，会有编译警告，严肃对待这一点。</li>
</ul>
</li>
<li><p>一般而言，更倾向于使用集合。</p>
</li>
</ul>
<p>集合都有的方法：</p>
<ul>
<li><p><code>==</code>：比较身份，身份相同返回<code>true</code>，否则返回<code>false</code></p>
<ul>
<li>对原始类型来说，值就是身份。</li>
<li>对对象类型来说，身份是指堆中的存储地址。</li>
</ul>
</li>
<li><p><code>equals(Object o)</code>：</p>
</li>
<li><code>hashCode()</code>：返回一个近似随机的int值，这个值在对象的生命周期中不会改变。</li>
<li><code>toString</code>：返回一个包含该对象信息的String值，通常包含其类型和hashCode。</li>
</ul>
<h3 id="Object-Oriented-Programming-in-Java-and-Functional-Correctness"><a href="#Object-Oriented-Programming-in-Java-and-Functional-Correctness" class="headerlink" title="Object-Oriented Programming in Java and Functional Correctness"></a>Object-Oriented Programming in Java and Functional Correctness</h3><p><strong>类与接口</strong></p>
<p>在Java中，一个API可以被接口或类定义，</p>
<ul>
<li>接口仅提供了一个API，指定了期望。</li>
<li>类提供了一个API及其实现，指定并实现了期望。</li>
</ul>
<p>一个类的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">cat</span><span class="params">(String name)</span></span>&#123; <span class="comment">//构造器</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类定义并实现了API</span></span><br></pre></td></tr></table></figure>
<p>一个接口的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">animal</span></span>&#123;</span><br><span class="line">    <span class="comment">//没有构造器、没有数据域、没有方法实现！</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个接口仅定义了API，但没有实现。</span></span><br></pre></td></tr></table></figure>
<p>一个实现该接口的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> <span class="keyword">implements</span> <span class="title">animal</span></span>&#123;</span><br><span class="line">    <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String owner;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">cat</span><span class="params">(String name, String owner)</span></span>&#123; <span class="comment">//构造器</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.owner = owner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//额外的（接口中没有的）方法</span></span><br><span class="line">    <span class="function">String <span class="title">getOwner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个类实现接口时，可以添加接口中没有的方法。</span></span><br></pre></td></tr></table></figure>
<p>在使用该接口时，可以用接口类型变量去引用实现的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">animalUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        animal miaomiao = <span class="keyword">new</span> cat(<span class="string">"miaomiao"</span>, <span class="string">"dongbaiyue"</span>);</span><br><span class="line">        System.out.println(miaomiao.getName());</span><br><span class="line">        <span class="comment">//System.out.println(miaomiao.getOwner());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用接口去引用对象，那么将无法使用实现类中额外的方法（如<code>getOwner()</code>）（除非向下转型，这一点之后会谈到）。</p>
<p>也可以使用类变量去引用实现的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">animalUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cat miaomiao = <span class="keyword">new</span> cat(<span class="string">"miaomiao"</span>, <span class="string">"dongbaiyue"</span>);</span><br><span class="line">        System.out.println(miaomiao.getName());</span><br><span class="line">        System.out.println(miaomiao.getOwner());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用时，</p>
<ul>
<li><p>如果能够找到一个合适的接口包含了所有需要使用的方法，那么优先通过接口引用对象。这有以下好处：</p>
<ul>
<li><p>可以指明要使用哪个接口的方法，类中其余方法不需要考虑。</p>
</li>
<li><p>程序更加灵活。当你决定更换为另一个实现时，只需更改声明中构造器的名称即可，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animal miaomiao = <span class="keyword">new</span> dog(<span class="string">"miaomiao"</span>, <span class="string">"dongbaiyue"</span>);<span class="comment">//这个名字就有点怪了。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如果没有合适的接口，也可以类来引用对象。</p>
</li>
</ul>
<p><strong>信息隐藏</strong></p>
<p>信息隐藏是指隐藏类内部的数据和具体实现。这有以下好处：</p>
<ul>
<li>将相互关联的类解耦</li>
<li>不会依赖于类的内部的数据和具体实现，易于维护、修改、优化。</li>
<li>提高程序的可复用性。解耦的类更可能被复用。</li>
</ul>
<p>有以下访问权限修饰符：</p>
<ul>
<li><code>private</code>：只有在声明类内部可以访问。</li>
<li><code>package-private</code>：在同一个包中可访问，默认权限（即不加修饰符时）。</li>
<li><code>protected</code>：在同一个包中可访问，并且子类在任何位置都可以访问。</li>
<li><code>public</code>：在任何位置都可以访问。</li>
</ul>
<p>设计类时，仅将必要的功能提供给使用者，其他成员均为<code>private</code>。（当你的API有大量的使用者时，它的每一个外部特性都可能被利用、依赖，因此做好信息隐藏）</p>
<p><strong>合同</strong></p>
<p>与MIT的内容大致相同。</p>
<h3 id="Testing-exceptions-and-behavior-subtyping"><a href="#Testing-exceptions-and-behavior-subtyping" class="headerlink" title="Testing,exceptions,and behavior subtyping"></a>Testing,exceptions,and behavior subtyping</h3><p><strong>行为子类型</strong></p>
<blockquote>
<p>Let $q(x)$ be a property provable about objects x of type T. Then $q(y)$ shoule be provable for objects y of type S where S is a subtype of T. </p>
<p>​                                                                                                                           ——Barbara Liskov</p>
</blockquote>
<p>里氏替换原则：如果$q(x)$对$T$类型的$x$是行为可保证的，而$y$的类型$S$是$T$的子类型，那么$q(y)$对$y$也应当是可保证的。</p>
<p>另一种表述是：派生类（子类）对象可以在程序中替代其基类（父类）对象。</p>
<p>编译器强制要求的规则：</p>
<ul>
<li>子类型可以添加，但不能移除方法。</li>
<li>具体类必须实现所有未实现方法。</li>
<li>重写方法必须返回相同类型、或原来返回类型的子类型。</li>
<li>重写方法必须接受相同参数类型。</li>
<li>重写方法不能抛出原来不会抛出的异常</li>
</ul>
<p>其余规则：</p>
<ul>
<li>相同或更强的不变量</li>
<li>相同或更强的后置条件</li>
<li>相同或更弱的前置条件</li>
</ul>
<p>行为子类型必须满足上述规则！</p>
<p><strong>集合通用的方法</strong></p>
<ul>
<li><p><code>equals(Object o)</code>：如果两个对象“相等”，返回true.</p>
</li>
<li><p><code>hashCode()</code>：返回一个近似随机的int值，这个值在对象的生命周期中不会改变。特别的，</p>
<ul>
<li>对于”相等“的对象，他们的hashcode()值必须相等；</li>
<li>对于不”相等“的对象，他们的hashcode()值可能不等。</li>
</ul>
<p>该方法的意义在于简化比较”相等“的步骤，如果两个对象的hashcode()值不等，则他们一定不“相等”。</p>
</li>
<li><p><code>toString</code>：返回一个包含该对象信息的String值，通常包含其类型和hashCode。</p>
<ul>
<li>比如，java.lang.Object@659e0bfd</li>
</ul>
</li>
</ul>
<p><code>equals()</code>方法：”相等“是人为定义的一种等价关系（自反、对称、传递）。应当满足</p>
<ul>
<li>自反性。对于任何非null的引用值x，x.equals(x)应返回true。</li>
<li>对称性。对于任何引用x和y，如果x.equals(y)返回true，那么y.equals(x)也应该返回true。</li>
<li>传递性。对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true。</li>
<li>一致性。如果x和y引用的对象没有发生变化，那么反复调用x.equals(y)应该返回同样的结果。</li>
<li>非空性。对于任何非空引用x，x.equal(null)应返回false。</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> areaCode;  <span class="comment">//区号，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> prefix;    <span class="comment">//前缀，如+86</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> lineNumber;<span class="comment">//电话号码</span></span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">//使用@Override提高可读性，表明其为重写方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> PhoneNumber))&#123;<span class="comment">//instanceof，判断对象是否为给定类型</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PhoneNumber phoneNmuber = (PhoneNumber) o;</span><br><span class="line">        <span class="comment">//“相等”定义：区号、前缀、电话号码均相等</span></span><br><span class="line">        <span class="keyword">return</span> phoneNmuber.lineNumber; == <span class="keyword">this</span>.lineNumber</span><br><span class="line">        &amp;&amp; phoneNmuber.prefix == <span class="keyword">this</span>.prefix</span><br><span class="line">        &amp;&amp; phoneNmuber.areaCode == <span class="keyword">this</span>.areaCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hashCode()</code>方法</p>
<ul>
<li>如果重写<code>equals()</code>方法，总是重写<code>hashCode()</code>方法</li>
<li>不”相等“的对象的hashcode()值应当尽量不等（提高效率）</li>
<li>hashcode()值不应当发生改变，除非对象本身改变。</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> areaCode;  <span class="comment">//区号，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> prefix;    <span class="comment">//前缀，如+86</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> lineNumber;<span class="comment">//电话号码</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        \\</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：这三个方法IDE可以自动生成，在eclipse中为：右键$\to$source$\to$Generate $\cdots$</p>
<h3 id="Design-for-reuse-delegation-and-inheritance"><a href="#Design-for-reuse-delegation-and-inheritance" class="headerlink" title="Design for reuse: delegation and inheritance"></a>Design for reuse: delegation and inheritance</h3><p>软件设计的指标</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指标</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Functional correctness(功能正确性)</td>
<td style="text-align:center">实现符合规约</td>
</tr>
<tr>
<td style="text-align:center">Robustness(鲁棒性)</td>
<td style="text-align:center">处理非法情况的能力</td>
</tr>
<tr>
<td style="text-align:center">Flexibility(灵敏性)</td>
<td style="text-align:center">适应规约变化的能力</td>
</tr>
<tr>
<td style="text-align:center">Ruseability(可复用性)</td>
<td style="text-align:center">在另一个应用中被复用的能力</td>
</tr>
<tr>
<td style="text-align:center">Efficiency(性能)</td>
<td style="text-align:center">满足时间和存储空间要求</td>
</tr>
<tr>
<td style="text-align:center">Scalability(可扩展性)</td>
<td style="text-align:center">充当一个更大应用的基础的能力</td>
</tr>
<tr>
<td style="text-align:center">Security(安全性)</td>
<td style="text-align:center">软件安全性的考虑程度/级别</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Delegation(委托)</strong></p>
<p>委托就是一个对象依赖另一个对象来实现它的某个子功能。一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> A a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a.print(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B类将A类对象作为自己的成员变量，调用A类的方法实现委托。</span></span><br></pre></td></tr></table></figure>
<p>委托设计两个参与者：</p>
<ul>
<li>Delegator(委托者)：上例中的B是Delegator。</li>
<li>Delegate(被委托者)：接受委托者的调用，帮助Delegator实现功能。上例中的A是Delegate。</li>
</ul>
<p>如何设计委托</p>
<ul>
<li>接口应该小，且具有明确的规约</li>
<li>类应当将算法、行为封装起来</li>
</ul>
<p>合理的委托能够提高代码的可复用性。</p>
<p><strong>补充内容，以便后续</strong></p>
<p><strong>抽象类</strong>：不能实例化对象的类，声明时加上<code>abstract</code>，除了不能实例化对象外与一般的类没有区别。可以认为是类与接口的混合。如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。</p>
<p><strong>抽象方法</strong>：类中没有这个方法的实现，而由该类的子类实现。声明时加上<code>abstract</code>，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li>如果一个类包含抽象方法，那么该类必须是抽象类。或者说，只有抽象类才能包含抽象方法。</li>
<li>任何子类必须重写父类的抽象方法，或者声明其自身为抽象类。</li>
<li>构造方法、类方法（用static修饰的）不能声明为抽象方法。</li>
</ul>
<p>implements和extends</p>
<ul>
<li>implements，实现，用于类实现一个或多个接口。<ul>
<li>实现接口就要实现该接口所有方法（抽象类的抽象方法除外）</li>
<li>多个类可以实现同一个接口，一个类也可以实现多个接口</li>
</ul>
</li>
<li>extends，继承，用于接口之间（子接口和父接口）、类之间（子类和父类）的继承关系<ul>
<li>Java中类是单继承的，子类只能继承一个父类；</li>
<li>Java中接口是多继承的，子接口可以继承一个或多个父接口。</li>
</ul>
</li>
</ul>
<p><strong>Inheritance(继承)</strong></p>
<p><code>super</code>和<code>this</code>用于构造器</p>
<ul>
<li><p><code>super(参数)</code>调用父类相同形参的构造方法，必须在构造函数的第一句。</p>
</li>
<li><p><code>this(参数)</code>调用该类相同形参的另一个构造方法，必须在构造函数的第一句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cat</span> <span class="keyword">extends</span> <span class="title">animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">cat</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">super</span>(name);            <span class="comment">//调用父类构造方法，形参类型与name相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"miaomiao"</span>);       <span class="comment">//调用该类另一个（在此例即上一个）构造方法，形参类型</span></span><br><span class="line">                                <span class="comment">//与"miaomiao"相同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注：使用<code>super.</code>还可以调用父类方法。</p>
<p><code>final</code>作用</p>
<ul>
<li><code>final</code>数据域：引用固定，初始化后不能再次赋值</li>
<li><code>final</code>方法：不能重写该方法</li>
<li><code>final</code>类：不能继承该类</li>
</ul>
<p>继承 vs 委托</p>
<ul>
<li>继承提高了模块的灵敏度</li>
<li>通常，优先使用委托而非继承。这有以下好处<ul>
<li>继承不利于信息隐藏</li>
<li>委托支持信息隐藏</li>
</ul>
</li>
</ul>
<p>一个隐晦的bug</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Number</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number == number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Set&lt;Number&gt; numberSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        numberSet.add(<span class="keyword">new</span> Number(<span class="number">3</span>));</span><br><span class="line">        System.out.println(numberSet.contains(<span class="keyword">new</span> Number(<span class="number">3</span>)));</span><br><span class="line">    &#125;numberSet</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出:false</span></span><br></pre></td></tr></table></figure>
<p>造成bug的原因是，类中<code>equals</code>方法参数为<code>int</code>而非<code>Object</code>，因此是重载而非重写。而<code>contains</code>方法的实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>new</code>的对象被转换为<code>Object</code>类型，因此<code>equals</code>方法的参数为<code>Object</code>类型，从而调用了父类<code>Object</code>的<code>equals</code>，比较引用是否相等。</p>
<h3 id="Introduction-to-Design-Patterns"><a href="#Introduction-to-Design-Patterns" class="headerlink" title="Introduction to Design Patterns"></a>Introduction to Design Patterns</h3><p><strong>UML类图</strong></p>
<p>UML(Unified Modeling Language)，统一建模语言，在这门课中用到</p>
<ul>
<li>UML类图</li>
<li>UML序列图</li>
</ul>
<p>关于UML类图及设计模式的内容请参见<a href="">HIT-软件构造(三)</a>？</p>
<h3 id="A-formal-design-process-Domain-modeling"><a href="#A-formal-design-process-Domain-modeling" class="headerlink" title="A formal design process: Domain modeling"></a>A formal design process: Domain modeling</h3><p><strong>交互图：可视化动态行为</strong></p>
<p>交互图：显示了在一个应用场景下，系统与外界、或是子系统之间发生的事件。</p>
<p>UML时序图</p>
<p><img src="/images/HIT-SoftwareConstruction2/image-20200504202045054.png" alt="image-20200504202045054"></p>
<ul>
<li>控制信息<ul>
<li>条件控制，当表达式为真发送消息，语法：[表达式]消息标签</li>
<li>迭代，当表达式为真迭代结束，语法：*[表达式]消息标签</li>
</ul>
</li>
<li></li>
</ul>
<p><strong>面向对象分析：理解问题</strong></p>
<p>设计过程：</p>
<ul>
<li>问题建模、图解，明确对象<ul>
<li>领域模型</li>
</ul>
</li>
<li>明确系统行为<ul>
<li>系统时序图</li>
<li>系统行为规约/合同</li>
</ul>
</li>
<li>分配对象职责，定义对象交互<ul>
<li>对象交互图</li>
</ul>
</li>
<li>解决方案建模、图解<ul>
<li>对象模型</li>
</ul>
</li>
</ul>
<p>领域模型：描述概念、概念之间关系的模型，可以使用UML类图来表示。</p>
<ul>
<li>概念是指真实世界的概念，可以是名词、动词。</li>
<li>关系是指现实世界的关系</li>
<li>不需要考虑方法/操作</li>
</ul>
<p>系统时序图：基于上述领域模型，描述一个应用场景。</p>
<ul>
<li>只包括领域级别的概念、操作</li>
</ul>
<p>系统行为规约/合同：为在系统时序图中出现的方法/操作设定前置、后置条件。</p>
<h3 id="A-formal-design-process-Responsibility-assignment"><a href="#A-formal-design-process-Responsibility-assignment" class="headerlink" title="A formal design process: Responsibility assignment"></a>A formal design process: Responsibility assignment</h3><p><strong>使用交互图来分配对象职责</strong></p>
<p>交互图：在给定的系统级操作的基础上，描述 实现级别的 对象交互。实现级别的概念有：</p>
<ul>
<li>方法名</li>
<li>类型</li>
<li>辅助方法、辅助类</li>
<li>设计模式</li>
</ul>
<p>交互图描述了对象的交互，而对象的交互又对应于对象的API。</p>
<p>职责驱动的设计(OOD)：职责是一种隐喻，把对象看作具有某种职责的人，他要与其他人协作以完成工作。</p>
<p>SOLID原则</p>
<ul>
<li>单一责任原则（Single Responsibility Principle）：</li>
<li>开放封闭原则（Open Closed Principle）：对扩展开放、对修改关闭。使用继承和组合来进行扩展。</li>
<li>里氏替换原则</li>
<li>接口隔离原则（Interface Segregation Principle）：客户端不应依赖于它们不需要的方法，将胖的接口分解为小接口</li>
<li>依赖倒置原则（Dependency Inversion Principle）：实现依赖于接口，对接口编程而不是对实现编程。</li>
</ul>
<p>GRASP是General Responsibility Assignment Software Patterns（通用职责分配模式）的缩写。GRASP模式对基本的职责分配的原则进行了命名和描述，包括</p>
<ul>
<li><p>创建者(Creator)</p>
<ul>
<li>问题：由谁去创建对象$Y$？（此时的对象指的是 实现级别的 对象）</li>
<li>建议：创建对象$Y$的类$X$应具有以下特点之一（具有越多越好）<ul>
<li>$X$包含或聚合了$Y$</li>
<li>$X$记录$Y$</li>
<li>$X$紧密使用$Y$</li>
<li>$X$具有$Y$的初始化数据</li>
</ul>
</li>
<li>意义：减少不必要的耦合。</li>
</ul>
</li>
<li><p>信息专家(Information Expert)</p>
<ul>
<li>问题：某个职责应该分配给谁？</li>
<li><p>建议：把职责分配给具有完成该职责所需信息的那个类。</p>
</li>
<li><p>意义：减少不必要的耦合。</p>
</li>
</ul>
</li>
<li><p>低耦合(Low Coupling)</p>
<ul>
<li>问题：如何减少因变化产生的影响？</li>
<li>建议：合理分配职责以使（不必要的）耦合保持在较低水平。该原则被用来评估可选方案。</li>
</ul>
</li>
<li><p>控制器(Controller)</p>
<ul>
<li>问题：由谁去首先接收外部输入，协调、委派工作？</li>
<li>建议：<ul>
<li>代表整个“系统”、“主要子系统”的外观控制器</li>
<li>代表用例场景的用例控制器</li>
</ul>
</li>
</ul>
</li>
<li><p>高内聚(High Cohesion)</p>
<ul>
<li>问题：怎样使对象内聚、易于理解、易于管理，同时具有低耦合的额外作用？</li>
<li>建议：职责分配应保持高内聚。</li>
</ul>
</li>
</ul>
<p><strong>对象模型</strong></p>
<p>从交互图中抽取出数据、方法名、类型建立对象模型。补全实现细节，如访问权限。</p>
<h3 id="Introduction-to-concurrency-and-GUIs"><a href="#Introduction-to-concurrency-and-GUIs" class="headerlink" title="Introduction to concurrency and GUIs"></a>Introduction to concurrency and GUIs</h3><h3 id="Design-case-syudies-Java-Swing"><a href="#Design-case-syudies-Java-Swing" class="headerlink" title="Design case syudies: Java Swing"></a>Design case syudies: Java Swing</h3><ul>
<li><p>(Model-View-Controller)</p>
<ul>
<li>问题：</li>
</ul>
</li>
</ul>
<h3 id="Design-case-study-Java-Collections"><a href="#Design-case-study-Java-Collections" class="headerlink" title="Design case study: Java Collections"></a>Design case study: Java Collections</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cs.cmu.edu/~charlie/courses/17-214/2019-fall" target="_blank" rel="noopener">CMU 17-214课程: Principles of Software Construction</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>1180300308-刘义
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://dongbaiyue.github.io/2020/07/10/HIT-SoftwareConstruction2/" title="HIT-软件构造(二)">https://dongbaiyue.github.io/2020/07/10/HIT-SoftwareConstruction2/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/HIT/" rel="tag"># HIT</a>
              <a href="/tags/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/" rel="tag"># 课程学习</a>
              <a href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/" rel="tag"># 软件构造</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/30/HIT-SoftwareConstruction1/" rel="prev" title="HIT-软件构造(一)">
      <i class="fa fa-chevron-left"></i> HIT-软件构造(一)
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/10/HIT-SoftwareConstruction3/" rel="next" title="HIT-软件构造(三)">
      HIT-软件构造(三) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Introduction-to-Java"><span class="nav-number">2.</span> <span class="nav-text">Introduction to Java</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-Oriented-Programming-in-Java-and-Functional-Correctness"><span class="nav-number">3.</span> <span class="nav-text">Object-Oriented Programming in Java and Functional Correctness</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Testing-exceptions-and-behavior-subtyping"><span class="nav-number">4.</span> <span class="nav-text">Testing,exceptions,and behavior subtyping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Design-for-reuse-delegation-and-inheritance"><span class="nav-number">5.</span> <span class="nav-text">Design for reuse: delegation and inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Introduction-to-Design-Patterns"><span class="nav-number">6.</span> <span class="nav-text">Introduction to Design Patterns</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-formal-design-process-Domain-modeling"><span class="nav-number">7.</span> <span class="nav-text">A formal design process: Domain modeling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-formal-design-process-Responsibility-assignment"><span class="nav-number">8.</span> <span class="nav-text">A formal design process: Responsibility assignment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Introduction-to-concurrency-and-GUIs"><span class="nav-number">9.</span> <span class="nav-text">Introduction to concurrency and GUIs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Design-case-syudies-Java-Swing"><span class="nav-number">10.</span> <span class="nav-text">Design case syudies: Java Swing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Design-case-study-Java-Collections"><span class="nav-number">11.</span> <span class="nav-text">Design case study: Java Collections</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料"><span class="nav-number">12.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="1180300308-刘义"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">1180300308-刘义</p>
  <div class="site-description" itemprop="description">这里是东百月的园地</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dongbaiyue" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dongbaiyue" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/dong-bai-yue-69" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;dong-bai-yue-69" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2681514899@qq.com" title="E-Mail → mailto:2681514899@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">1180300308-刘义</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'mcAf4MCU7LoDcVSt7UrEUOqa-MdYXbMMI',
      appKey     : 'auKPdtKuG2HM2Ffbpu17U83N',
      placeholder: "来说点什么吧~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>

<!-- 文件位置：~/theme/next/layout/_layout.swig -->

<script type="text/javascript" src="/js/clicklove.js"></script>
